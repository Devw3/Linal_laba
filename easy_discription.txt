Task1 - is_palindrome(n): функция проверяет число на палиндром, то есть если оно читается одинаково с начала и конца. математически это сравнение строки с её обратной, s == s[::-1].
is_prime(n): простая проверка на простоту, перебираем делители от 2 до sqrt(n), если делится - не простое.
is_circular_prime(p): для циклической простоты - сначала смотрим, чтобы цифры не были чётными или 5 (иначе ротация будет делиться на 2/5), потом генерируем все ротации и проверяем каждую на простоту.
palindromic_squares_and_circular_primes(): ищем a < 100000 такие, что a - палиндром и a^2 тоже, просто перебор. для циклических простых - все p < 1e6, которые простые и все их ротации тоже.

Task2 - palindromic_cubes_and_palindromic_primes(): аналогично, a - палиндром и a^3 - палиндром, перебор. палиндромические простые - p < 10001, простое и палиндром.

Task3 - generate_primes_from_digits(allowed_digits, count): bfs в очереди, начинаем с одноциферных (не 0), добавляем цифры из allowed, проверяем на простоту, пока не найдём count штук.
primes_with_two_digits(): для каждого сета цифр типа '13' вызываем функцию выше на 100 простых.

Task4 - count_primes_up_to(n): просто считаем сколько простых <= n, перебором с is_prime.
twin_primes_analysis(limit_pairs): ищем пары (n, n+2) простых, пока не найдём limit_pairs. для каждой пары считаем отношение число пар / число простых до n+2, математически pi_2(n)/pi(n), которое падает к нулю.

Task5 - factorial(n): обычный факториал, умножаем от 2 до n.
prime_factorial(n): sympy.factorint - разложение на простые с показателями.
factorial_plus_one_factors(): для n=2..50 считаем n! + 1, разлагаем, ищем n с max разными простыми, и большие простые >1e6.

Task6 - gcd(a, b): евклид, пока b != 0, a = b, b = a % b.
euler_phi_direct(n): прямой счёт, для k=1..n если gcd(k,n)==1 то +1.
euler_phi_factor(n): через разложение, phi = n * product(1-1/p) для p|n.

compare_euler_phi_methods(test_values): меряем время для трёх способов на больших n, direct медленный, factor и sympy быстрые.
